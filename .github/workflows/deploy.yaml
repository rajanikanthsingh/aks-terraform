name: AKS Terraform + CI/CD

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:

  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    outputs:
      acr_login_server: ${{ steps.tf_output.outputs.acr_login_server }}
      key_vault_uri: ${{ steps.tf_output.outputs.key_vault_uri }}
      aks_name: ${{ steps.tf_output.outputs.aks_name }}
      rg_name: ${{ steps.tf_output.outputs.rg_name }}
    env:
      ARM_SUBSCRIPTION_ID: ${{ secrets.AKSTERRAFORM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AKSTERRAFORM_TENANT_ID }}
      ARM_CLIENT_ID: ${{ secrets.AKSTERRAFORM_CLIENT_ID }}
      ARM_CLIENT_SECRET: ${{ secrets.AKSTERRAFORM_CLIENT_SECRET }}
      TF_VAR_db_password: ${{ secrets.AKSTERRAFORM_DB_PASSWORD }}
      TF_VAR_github_actions_client_id: ${{ secrets.AKSTERRAFORM_CLIENT_ID }}
      TF_VAR_node_size: standard_dc2s_v3
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Login to Azure
        run: |
          az login --service-principal -u ${{ secrets.AKSTERRAFORM_CLIENT_ID }} \
                           -p ${{ secrets.AKSTERRAFORM_CLIENT_SECRET }} \
                           --tenant ${{ secrets.AKSTERRAFORM_TENANT_ID }}

      - name: Delete partially created Resource Group (safe for rerun)
        run: |
          set -euo pipefail
          if az group show -n rg-aks-demo &>/dev/null; then
            echo "Deleting resource group rg-aks-demo..."
            az group delete -n rg-aks-demo --yes --no-wait
          else
            echo "Resource group 'rg-aks-demo' not found; skipping delete."
          fi

      - name: Clean orphan Key Vault access policy (idempotent)
        run: |
          set -euo pipefail
          # Only attempt cleanup if the Key Vault exists
          if az keyvault show --name kvaksdemo --resource-group rg-aks-demo &>/dev/null; then
            echo "Key Vault 'kvaksdemo' exists — attempting to remove access policy for this SP (if present)"
            OBJECT_ID=$(az ad sp show --id "${{ secrets.AKSTERRAFORM_CLIENT_ID }}" --query objectId -o tsv || echo "")
            if [ -n "$OBJECT_ID" ]; then
              echo "Removing access policy for object id: $OBJECT_ID"
              az keyvault delete-policy --name kvaksdemo --object-id "$OBJECT_ID" || echo "No existing policy or deletion failed (continuing)"
            else
              echo "Could not resolve service principal object id; skipping delete-policy."
            fi
          else
            echo "Key Vault 'kvaksdemo' not found in 'rg-aks-demo' — skipping access policy cleanup."
          fi

          # Also ensure no local stale state exists on the runner
          echo "Cleaning terraform working directory on runner..."
          rm -rf terraform/.terraform || true
          rm -f terraform/.terraform.lock.hcl || true
          rm -f terraform/terraform.tfstate terraform/terraform.tfstate.backup || true

      - name: Terraform Init (with backend-config from secrets)
        working-directory: terraform
        env:
          TF_BACKEND_RG: ${{ secrets.TF_BACKEND_RG }}
          TF_BACKEND_STORAGE_ACCOUNT: ${{ secrets.TF_BACKEND_STORAGE_ACCOUNT }}
          TF_BACKEND_CONTAINER: ${{ secrets.TF_BACKEND_CONTAINER }}
          TF_BACKEND_KEY: ${{ secrets.TF_BACKEND_KEY }}
          TF_BACKEND_ACCESS_KEY: ${{ secrets.TF_BACKEND_ACCESS_KEY }}
        run: |
          set -euo pipefail
          ARGS="-reconfigure"
          if [ -n "${TF_BACKEND_RG:-}" ]; then ARGS="$ARGS -backend-config=resource_group_name=${TF_BACKEND_RG}"; fi
          if [ -n "${TF_BACKEND_STORAGE_ACCOUNT:-}" ]; then ARGS="$ARGS -backend-config=storage_account_name=${TF_BACKEND_STORAGE_ACCOUNT}"; fi
          if [ -n "${TF_BACKEND_CONTAINER:-}" ]; then ARGS="$ARGS -backend-config=container_name=${TF_BACKEND_CONTAINER}"; fi
          if [ -n "${TF_BACKEND_KEY:-}" ]; then ARGS="$ARGS -backend-config=key=${TF_BACKEND_KEY}"; fi
          if [ -n "${TF_BACKEND_ACCESS_KEY:-}" ]; then ARGS="$ARGS -backend-config=access_key=${TF_BACKEND_ACCESS_KEY}"; fi
          echo "Running: terraform init $ARGS"
          terraform init $ARGS

      - name: Try importing existing Resource Group (idempotent)
        working-directory: terraform
        run: |
          set -euo pipefail
          # Only attempt import if the resource group exists in the subscription
          if az group show -n rg-aks-demo &>/dev/null; then
            SUBSCRIPTION_ID=$(az account show --query id -o tsv)
            RG_ID="/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/rg-aks-demo"
            echo "Attempting to import existing resource group: $RG_ID"
            terraform import azurerm_resource_group.rg "$RG_ID" || echo "Import failed or already imported (continuing)"
          else
            echo "Resource group 'rg-aks-demo' does not exist; skipping import."
          fi

      - name: Try importing existing Key Vault, ACR, and AKS (idempotent)
        working-directory: terraform
        run: |
          set -euo pipefail
          RG_NAME="rg-aks-demo"
          if az group show -n "$RG_NAME" &>/dev/null; then
            SUBSCRIPTION_ID=$(az account show --query id -o tsv)

            # Key Vault
            KV_NAME=$(az keyvault list -g "$RG_NAME" --query "[0].name" -o tsv || echo "")
            if [ -n "$KV_NAME" ]; then
              KV_ID="/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.KeyVault/vaults/${KV_NAME}"
              echo "Attempting to import Key Vault: $KV_ID"
              terraform import azurerm_key_vault.kv "$KV_ID" || echo "Key Vault import failed or already imported (continuing)"
            else
              echo "No Key Vault found in ${RG_NAME}; skipping Key Vault import."
            fi

            # Azure Container Registry
            ACR_NAME=$(az acr list -g "$RG_NAME" --query "[0].name" -o tsv || echo "")
            if [ -n "$ACR_NAME" ]; then
              ACR_ID="/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.ContainerRegistry/registries/${ACR_NAME}"
              echo "Attempting to import ACR: $ACR_ID"
              terraform import azurerm_container_registry.acr "$ACR_ID" || echo "ACR import failed or already imported (continuing)"
            else
              echo "No ACR found in ${RG_NAME}; skipping ACR import."
            fi

            # AKS Cluster
            AKS_NAME=$(az aks list -g "$RG_NAME" --query "[0].name" -o tsv || echo "")
            if [ -n "$AKS_NAME" ]; then
              AKS_ID="/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${RG_NAME}/providers/Microsoft.ContainerService/managedClusters/${AKS_NAME}"
              echo "Attempting to import AKS: $AKS_ID"
              terraform import azurerm_kubernetes_cluster.aks "$AKS_ID" || echo "AKS import failed or already imported (continuing)"
            else
              echo "No AKS cluster found in ${RG_NAME}; skipping AKS import."
            fi

          else
            echo "Resource group '${RG_NAME}' does not exist; skipping resource imports."
          fi

      - name: Terraform Plan
        working-directory: terraform
        run: terraform plan

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      - name: Capture Terraform outputs
        working-directory: terraform
        id: tf_output
        run: |
          set -euo pipefail
          ACR_OUT=$(terraform output -raw acr_login_server)
          KV_OUT=$(terraform output -raw key_vault_uri)
          AKS_OUT=$(terraform output -raw aks_name)
          RG_OUT=$(terraform output -raw rg_name)

          # Use the GITHUB_OUTPUT heredoc format to safely write values
          echo "acr_login_server<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$ACR_OUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "key_vault_uri<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$KV_OUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "aks_name<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$AKS_OUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "rg_name<<EOF" >> $GITHUB_OUTPUT
          printf '%s\n' "$RG_OUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  fetch-secrets:
    name: Fetch Key Vault Secrets
    runs-on: ubuntu-latest
    needs: terraform
    env:
      AZURE_CLIENT_ID: ${{ secrets.AKSTERRAFORM_CLIENT_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.AKSTERRAFORM_CLIENT_SECRET }}
      AZURE_TENANT_ID: ${{ secrets.AKSTERRAFORM_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AKSTERRAFORM_SUBSCRIPTION_ID }}
      KEY_VAULT_URI: ${{ needs.terraform.outputs.key_vault_uri }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AKSTERRAFORM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AKSTERRAFORM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AKSTERRAFORM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AKSTERRAFORM_TENANT_ID }}"
            }

      - name: Derive Key Vault name from Terraform output
        run: |
          set -euo pipefail
          if [ -n "${KEY_VAULT_URI:-}" ]; then
            # Strip protocol and domain to get vault name (e.g. https://kvaksdemo.vault.azure.net/ -> kvaksdemo)
            KV_NAME=${KEY_VAULT_URI#https://}
            KV_NAME=${KV_NAME%%.*}
            echo "Derived Key Vault name: $KV_NAME"
            echo "KEYVAULT_NAME=$KV_NAME" >> $GITHUB_ENV
          else
            echo "KEY_VAULT_URI is empty; falling back to secret AKSTERRAFORM_KEYVAULT_NAME if present"
          fi

      - name: Fetch secrets from Key Vault
        uses: Azure/get-keyvault-secrets@v1
        with:
          keyvault: ${{ env.KEYVAULT_NAME || secrets.AKSTERRAFORM_KEYVAULT_NAME }}
          secrets: db-password  # Add other secret names as needed

      - name: Set secrets as env variables
        run: |
          echo "DB_PASSWORD=${{ steps.get-keyvault-secrets.outputs.db-password }}" >> $GITHUB_ENV

  build-and-deploy:
    name: Build Docker & Deploy to AKS
    runs-on: ubuntu-latest
    needs: fetch-secrets
    env:
      ACR_USERNAME: ${{ secrets.AKSTERRAFORM_ACR_USERNAME }}
      ACR_PASSWORD: ${{ secrets.AKSTERRAFORM_ACR_PASSWORD }}
      AKS_NAME: ${{ needs.terraform.outputs.aks_name }}
      RG_NAME: ${{ needs.terraform.outputs.rg_name }}
      ACR_LOGIN_SERVER: ${{ needs.terraform.outputs.acr_login_server }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AKSTERRAFORM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AKSTERRAFORM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AKSTERRAFORM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AKSTERRAFORM_TENANT_ID }}"
            }

      - name: Get AKS credentials
        run: |
          az aks get-credentials --resource-group $RG_NAME --name $AKS_NAME --overwrite-existing

      - name: Docker login to ACR
        uses: azure/docker-login@v1
        with:
          login-server: $ACR_LOGIN_SERVER
          username: $ACR_USERNAME
          password: $ACR_PASSWORD

      - name: Build Docker image
        run: |
          IMAGE_TAG=$ACR_LOGIN_SERVER/myapp:${{ github.sha }}
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          docker build -t $IMAGE_TAG .

      - name: Push Docker image
        run: docker push $IMAGE_TAG

      - name: Update Kubernetes deployment with new image
        run: sed -i "s|{{IMAGE}}|$IMAGE_TAG|g" k8s/deployment.yaml

      - name: Apply Kubernetes manifests
        run: kubectl apply -f k8s/
